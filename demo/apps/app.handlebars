
<!doctype html>
<meta charset="utf-8">
<title>{{title}}</title>
<link rel="stylesheet" href="https://dagrejs.github.io/project/dagre-d3/latest/demo/demo.css">
<script src="https://dagrejs.github.io/project/dagre-d3/latest/dagre-d3.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<h1>{{title}}</h1>
<style id="css">
    /* This sets the color for "TK" nodes to a light blue green. */
    g.type-TK>rect {
        fill: #00ffd0;
    }

    text {
        font-weight: 300;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size: 14px;
    }

    .node rect {
        stroke: #999;
        fill: #fff;
        stroke-width: 1.5px;
    }

    .edgePath path {
        stroke: #333;
        stroke-width: 1.5px;
    }
</style>

<section>
    <p>All possible paths superposed</p>
</section>

<svg id="svg-canvas" width=960 height=600></svg>

<div id="body">
    <p>DataURL: <a href="{{data}}">{{data}}</a></p>
</div>

<script id="js">

    function httpGetAsync(theUrl, callback) {
            var xmlHttp = new XMLHttpRequest();
            xmlHttp.onreadystatechange = function () {
                if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
                    callback(xmlHttp.responseText);
            }
            xmlHttp.open("GET", theUrl, true);
            xmlHttp.send(null);
        }

        httpGetAsync('{{data}}', function (response) {


            // Create the input graph
            var g = new dagreD3.graphlib.Graph()
                .setGraph({})
                .setDefaultEdgeLabel(function () { return {}; });

            let nodes = [];
            function addNode(node) {
                if (!nodes.includes(node)) {
                    g.setNode(nodes.length, { label: node, class: "type-TOP" });
                    nodes.push(node);
                }
            }

            function addPath(path){
                for (i = 0; i < path.length - 1; i++) {
                    let from = path[i];
                    let to = path[i + 1];
                    addNode(from);
                    addNode(to);
                    // Set up edges, no special attributes.
                    g.setEdge(nodes.indexOf(from), nodes.indexOf(to));
                }
            }


            // Parse the data and build the graph
            data = JSON.parse(response);
            let isList = x => x['@list']
            if (data['ex:hasPath']) {
                // Iterate paths
                Object.values(data['ex:hasPath'].filter(isList)).forEach(paths => {
                    Object.values(paths['@list'].filter(isList)).forEach(current => {
                        let path = current['@list'].map(x => x['@id']);
                        addPath(path);
                    });
                });
            }

            console.log(nodes);
            g.nodes().forEach(function (v) {
                var node = g.node(v);
                // Round the corners of the nodes
                node.rx = node.ry = 5;
            });

            // Create the renderer
            var render = new dagreD3.render();

            // Set up an SVG group so that we can translate the final graph.
            var svg = d3.select("svg"),
                svgGroup = svg.append("g");

            // Run the renderer. This is what draws the final graph.
            render(d3.select("svg g"), g);

            // Center the graph
            var xCenterOffset = (svg.attr("width") - g.graph().width) / 2;
            svgGroup.attr("transform", "translate(" + xCenterOffset + ", 20)");
            svg.attr("height", g.graph().height + 40);

        });
</script>
<script src="https://dagrejs.github.io/project/dagre-d3/latest/demo/demo.js"></script>
