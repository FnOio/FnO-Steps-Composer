
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix gps: <http://josd.github.io/eye/reasoning/gps/gps-schema#>.
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix o-steps: <https://fast.ilabt.imec.be/ns/oslo-steps/0.2#> .
@prefix : <http://example.org#>.

# find paths in the state space from initial state to goal state within limits
{?SCOPE gps:findpath (?Goal ?MarkedPath  ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort))} <= {
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort 1)).

#mark independent subpaths
?Path :mark (() ?MarkedPath).
}.


{?SCOPE gps:findpath (?Goal ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path  ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount)).

}.

{?SCOPE gps:findpaths (?Maps ?Goal ?Path ?Duration ?Cost ?Belief ?Comfort ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
#_:x e:trace 10.
    ?SCOPE e:call ?Goal.
#_:x e:trace 11.
    ("!") e:derive true.
#_:x e:trace 12.
}.
{?SCOPE gps:findpaths (?Maps_s ?Goal ?Path_s ?Duration_s ?Cost_s ?Belief_s ?Comfort_s ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    {?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n)} <= ?Where.
#_:x e:trace (1 ?Action). 
    ?SCOPE e:call ?From.
#_:x e:trace 2. 


#this test below can be critical in some applications
    ?SCOPE e:fail ?To.
#_:x e:trace 4. 
    ?SCOPE e:call ?Where.
_:x e:trace (3 ?Where). 

#modify here
    ?Path_s :permutationCheck ?Action.
#_:x e:trace 5.

    ?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n).
#_:x e:trace ("5a" {?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n).}  ).
    (?Maps_s (?Map)) list:append ?Maps_t.
#_:x e:trace "b".
    ?Maps_t gps:stagecount ?Stagecount.
#_:x e:trace 6.
    ?Stagecount math:notGreaterThan ?MaxStagecount.
#_:x e:trace 7.
    (?Duration_s ?Duration_n) math:sum ?Duration_t.
    ?Duration_t math:notGreaterThan ?MaxDuration.
    (?Cost_s ?Cost_n) math:sum ?Cost_t.
    ?Cost_t math:notGreaterThan ?MaxCost.
    (?Belief_s ?Belief_n) math:product ?Belief_t.
    ?Belief_t math:notLessThan ?MinBelief.
    (?Comfort_s ?Comfort_n) math:product ?Comfort_t.
    ?Comfort_t math:notLessThan ?MinComfort.
    (?Path_s (?Action)) list:append ?Path_t.
#_:x e:trace 8.

    ?From e:becomes ?To.
#_:x e:trace (9 ?To).

    {?SCOPE gps:findpaths (?Maps_t ?Goal ?Path_t ?Duration_t ?Cost_t ?Belief_t ?Comfort_t ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} e:finalize {?To e:becomes ?From}.
}.

# counting the number of stages (a stage is a sequence of steps in the same map)
{() gps:stagecount 1} <= {
}.
{?A gps:stagecount ?B} <= {
    ?A e:firstRest (?C ?D).
    ?D e:firstRest (?E ?F).
    ?C log:notEqualTo ?E.
    ("!") e:derive true.
    ?D gps:stagecount ?G.
    (?G 1) math:sum ?B.
}.
{?A gps:stagecount ?B} <= {
    ?A e:firstRest (?C ?D).
    ?D gps:stagecount ?B.
}.



#Check for permutations


{?Path_s :permutationCheck ?Action.}<=
{
#_:x e:trace "hier permutation".
?Action  o-steps:requiresState o-steps:emptyState. 

("!") e:derive true.
?Path_s :independentTail ( () ?tail).
(?sub ?tail) list:append ?Path_s.


(?tail (?Action)) list:append ?tail2.

?sub :store ?tail2.
}.




{?Path_s :permutationCheck ?Action.}<={}.







#independentTail
{?path :independentTail (?subtail ?tail)} <=
{
?path list:last ?last.
?last o-steps:requiresState o-steps:emptyState. 
("!") e:derive true.


(?first (?last) ) list:append ?path.
((?last) ?subtail  ) list:append ?subtail2.

?first :independentTail (?subtail2 ?tail)

}.

{?path :independentTail (?tail ?tail)} <= {}.


#Is permutation Of
{?a :isPermutationOf ?b}
<=
{


?a e:length ?n.
?b e:length ?n.


#this only works because here the list can't have duplicates.
?b :fullyIncludedIn ?a.
}.



{() :fullyIncludedIn ?a.} <= {}.

{?b :fullyIncludedIn ?a.}
<=
{
?b rdf:first ?first.

?first list:in ?a.
?b rdf:rest ?b2.

?b2 :fullyIncludedIn ?a.
}.

########################
#either create list or stop

{?sub :store ?tail}
<=
{?sub :followedBy ?tail2.

?tail2 :isPermutationOf ?tail.



("!") e:derive true.
("fail") e:derive true.
}.

{?sub :store ?tail}
<=
{


("assert" {?sub :followedBy ?tail.}) e:derive true.
?sub :followedBy ?tail.



}.



{() :mark (?MarkedPath ?MarkedPath).}
<=
{}.

{?Path :mark (?int  ?markedPath)}
<=
{
?Path list:last ?last.
?last o-steps:requiresState o-steps:emptyState. 
("!") e:derive true.

?Path :independentTail (() ?tail).
(?first ?tail ) list:append ?Path.
((("unorderedList" ?tail)) ?int  ) list:append ?int2.
?first :mark (?int2  ?markedPath)
}.

{?Path :mark (?int  ?markedPath)}
<=
{
?Path list:last ?last.
(?first (?last) ) list:append ?Path.
((?last) ?int  ) list:append ?int2.
?first :mark (?int2  ?markedPath)
}.

