# EYE Components for GPS -- Jos De Roo

@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix e: <http://eulersharp.sourceforge.net/2003/03swap/log-rules#>.
@prefix gps: <http://josd.github.io/eye/reasoning/gps/gps-schema#>.



# find paths in the state space from initial state to goal state within limits
{?SCOPE gps:findpath (?Goal ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort))} <= {
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort 1)).
}.
{?SCOPE gps:findpath (?Goal ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    ?SCOPE gps:findpaths (() ?Goal () 0.0 0.0 1.0 1.0 ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount)).
}.

{?SCOPE gps:findpaths (?Maps ?Goal ?Path ?Duration ?Cost ?Belief ?Comfort ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    ?SCOPE e:call ?Goal.
    ("!") e:derive true.
_:e e:trace "goal reached, cut".
}.
{?SCOPE gps:findpaths (?Maps_s ?Goal ?Path_s ?Duration_s ?Cost_s ?Belief_s ?Comfort_s ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} <= {
    {?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n)} <= ?Where.
    ?SCOPE e:call ?From.
    ?SCOPE e:call ?Where.
_:e e:trace (1 ?Where).
    ?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n).
_:e e:trace (11 {?Map gps:description (?From ?Transition ?To ?Action ?Duration_n ?Cost_n ?Belief_n ?Comfort_n)}).
    (?Maps_s (?Map)) list:append ?Maps_t.
_:e e:trace 12.
    ?Maps_t gps:stagecount ?Stagecount.
_:e e:trace 2.
    ?Stagecount math:notGreaterThan ?MaxStagecount.
_:e e:trace 21.
    (?Duration_s ?Duration_n) math:sum ?Duration_t.
_:e e:trace (22 ?Duration_t ?MaxDuration).
    ?Duration_t math:notGreaterThan ?MaxDuration.
_:e e:trace 23.
    (?Cost_s ?Cost_n) math:sum ?Cost_t.
_:e e:trace 24.
    ?Cost_t math:notGreaterThan ?MaxCost.
_:e e:trace 25.
    (?Belief_s ?Belief_n) math:product ?Belief_t.
_:e e:trace 3.
    ?Belief_t math:notLessThan ?MinBelief.
    (?Comfort_s ?Comfort_n) math:product ?Comfort_t.
    ?Comfort_t math:notLessThan ?MinComfort.
_:e e:trace 4.
    (?Path_s (?Action)) list:append ?Path_t.
    ?From e:becomes ?To.
_:e e:trace ("path" ?Path_t).



    {?SCOPE gps:findpaths (?Maps_t ?Goal ?Path_t ?Duration_t ?Cost_t ?Belief_t ?Comfort_t ?Path ?Duration ?Cost ?Belief ?Comfort (?MaxDuration ?MaxCost ?MinBelief ?MinComfort ?MaxStagecount))} e:finalize {?To e:becomes ?From}.
_:e e:trace 5.
}.

# counting the number of stages (a stage is a sequence of steps in the same map)
{() gps:stagecount 1} <= {
}.
{?A gps:stagecount ?B} <= {
    ?A e:firstRest (?C ?D).
    ?D e:firstRest (?E ?F).
    ?C log:notEqualTo ?E.
    ("!") e:derive true.
    ?D gps:stagecount ?G.
    (?G 1) math:sum ?B.
}.
{?A gps:stagecount ?B} <= {
    ?A e:firstRest (?C ?D).
    ?D gps:stagecount ?B.
}.




